{
  "metadata": {
    "title": "Console Lumen",
    "description": "Gérez vos fonctions serverless en toute simplicité"
  },
  "nav": {
    "dashboard": "Tableau de bord",
    "functions": "Fonctions",
    "events": "Événements",
    "workflows": "Workflows",
    "tenancy": "Locataires",
    "asyncJobs": "Tâches async",
    "history": "Historique",
    "runtimes": "Environnements",
    "configurations": "Configurations",
    "secrets": "Secrets",
    "apiKeys": "Clés API",
    "apiClient": "Client API",
    "apiDocs": "Docs API",
    "brandName": "Lumen",
    "gateway": "Passerelle",
    "rbac": "Contrôle d'accès",
    "volumes": "Volumes",
    "layers": "Couches",
    "notifications": "Notifications",
    "snapshots": "Snapshots"
  },
  "pages": {
    "dashboard": {
      "title": "Tableau de bord",
      "description": "Aperçu de vos fonctions serverless",
      "refresh": "Actualiser"
    },
    "functions": {
      "title": "Fonctions",
      "description": "Gérer et surveiller vos fonctions serverless"
    },
    "events": {
      "title": "Événements",
      "description": "Bus d'événements : topics / abonnements / groupes de consommateurs",
      "titles": {
        "loadError": "Failed to Load Event Bus",
        "createTopic": "Create Topic",
        "topics": "Topics",
        "publishTo": "Publish to {topic}",
        "subscriptions": "Subscriptions",
        "deliveries": "Deliveries",
        "flowControls": "Flow Controls",
        "seekCursor": "Seek Cursor",
        "replay": "Replay",
        "recentMessages": "Recent Messages",
        "outboxJobs": "Outbox Jobs"
      },
      "buttons": {
        "dismiss": "Dismiss",
        "refresh": "Refresh",
        "createTopic": "Create Topic",
        "publishEvent": "Publish Event",
        "enqueueOutbox": "Enqueue Outbox",
        "addSubscription": "Add Subscription",
        "disable": "Disable",
        "enable": "Enable",
        "confirm": "Confirm",
        "cancel": "Cancel",
        "saveFlow": "Save Flow",
        "seekCursor": "Seek Cursor",
        "replay": "Replay",
        "retry": "Retry"
      },
      "fields": {
        "topicName": "Topic Name",
        "description": "Description",
        "retentionHours": "Retention (hours)",
        "payloadJson": "Payload JSON",
        "headersJson": "Headers JSON",
        "orderingKey": "Ordering Key",
        "outboxMaxAttempts": "Outbox Max Attempts",
        "outboxBackoffBaseMs": "Outbox Backoff Base (ms)",
        "outboxBackoffMaxMs": "Outbox Backoff Max (ms)",
        "name": "Name",
        "consumerGroup": "Consumer Group",
        "type": "Type",
        "function": "Function",
        "workflow": "Workflow",
        "maxAttempts": "Max Attempts",
        "backoffBaseMs": "Backoff Base (ms)",
        "backoffMaxMs": "Backoff Max (ms)",
        "maxInflightUnlimited": "Max Inflight (0=unlimited)",
        "rateLimitPerSecUnlimited": "Rate Limit/s (0=unlimited)",
        "webhookOptional": "Webhook (optional)",
        "webhookUrl": "Webhook URL",
        "method": "Method",
        "timeoutMs": "Timeout (ms)",
        "signingSecret": "Signing Secret",
        "target": "Target",
        "cursor": "Cursor",
        "lag": "Lag",
        "backlog": "Backlog",
        "flow": "Flow",
        "status": "Status",
        "actions": "Actions",
        "maxInflight": "Max Inflight",
        "ratePerSecond": "Rate/s",
        "seekSequence": "Seek Sequence",
        "seekTimeRfc3339": "Seek Time (RFC3339)",
        "fromSequence": "From Sequence",
        "limit": "Limit",
        "fromTimeRfc3339": "From Time (RFC3339)",
        "cursorReset": "Cursor Reset",
        "seq": "Seq",
        "key": "Key",
        "attempt": "Attempt",
        "updated": "Updated",
        "error": "Error",
        "sequence": "Sequence",
        "published": "Published",
        "id": "ID",
        "message": "Message",
        "nextAttempt": "Next Attempt"
      },
      "placeholders": {
        "topicName": "orders.created",
        "payloadJson": "order_id: 123, amount: 10.5",
        "headersJson": "source: api",
        "orderingKey": "customer-42",
        "selectFunction": "Select function",
        "selectWorkflow": "Select workflow",
        "webhookUrl": "https://...",
        "webhookHeadersJson": "X-Source: nova"
      },
      "types": {
        "function": "function",
        "workflow": "workflow"
      },
      "labels": {
        "enabled": "enabled",
        "disabled": "disabled",
        "unlimited": "unlimited"
      },
      "deliveryStatus": {
        "queued": "queued",
        "running": "running",
        "succeeded": "succeeded",
        "dlq": "dlq"
      },
      "outboxStatus": {
        "pending": "pending",
        "publishing": "publishing",
        "published": "published",
        "failed": "failed"
      },
      "options": {
        "replayResetCursor": "Replay + reset cursor",
        "replayOnly": "Replay only"
      },
      "texts": {
        "retention": "Retention: {hours}h",
        "subscriptionBacklog": "r{inflight} / q{queued} / dlq{dlq}",
        "subscriptionFlow": "inflight {inflight} · rate {rate}/s",
        "selectedSubscription": "Subscription: {name}",
        "deliveryCursorSummary": "Cursor {cursor} · lag {lag} · oldest unacked {oldest}s"
      },
      "empty": {
        "noTopicsTitle": "No Topics Yet",
        "noTopicsDescription": "Create a topic first, then configure subscriptions and delivery policies.",
        "selectTopicTitle": "Select a Topic",
        "selectTopicDescription": "Choose a topic on the left before publishing messages or managing subscriptions.",
        "noSubscriptions": "No subscriptions.",
        "selectSubscription": "Select a subscription",
        "noDeliveries": "No deliveries yet.",
        "noMessages": "No messages.",
        "noOutboxJobs": "No outbox jobs."
      },
      "notices": {
        "topicNameRequired": "Topic name is required",
        "topicCreated": "Topic \"{name}\" created",
        "confirmTopicDelete": "Click delete again to confirm topic \"{name}\" deletion",
        "topicDeleted": "Topic \"{name}\" deleted",
        "selectTopicFirst": "Select a topic first",
        "subscriptionNameRequired": "Subscription name is required",
        "selectFunction": "Select a function",
        "selectWorkflow": "Select a workflow",
        "subscriptionCreated": "Subscription \"{name}\" created",
        "subscriptionToggled": "Subscription \"{name}\" {status}",
        "confirmSubscriptionDelete": "Click delete again to confirm subscription \"{name}\" deletion",
        "subscriptionDeleted": "Subscription \"{name}\" deleted",
        "selectSubscriptionFirst": "Select a subscription first",
        "subscriptionFlowUpdated": "Subscription flow controls updated",
        "publishSuccess": "Published message #{sequence} with {deliveries} delivery fanout",
        "outboxEnqueued": "Outbox enqueued: {id}",
        "replayQueued": "Replay queued {queued} deliveries",
        "cursorMoved": "Cursor moved. Next replay/invoke starts from sequence {sequence}",
        "deliveryRetryQueued": "Delivery retry queued",
        "outboxRetryQueued": "Outbox retry queued"
      },
      "errors": {
        "mustBeValidJson": "{fieldName} must be valid JSON",
        "createSubscriptionFailed": "Failed to create subscription",
        "updateSubscriptionFailed": "Failed to update subscription",
        "deleteSubscriptionFailed": "Failed to delete subscription",
        "updateSubscriptionFlowFailed": "Failed to update subscription flow controls",
        "publishFailed": "Failed to publish event",
        "enqueueOutboxFailed": "Failed to enqueue outbox event",
        "replayFailed": "Failed to replay",
        "seekCursorFailed": "Failed to seek subscription cursor",
        "retryDeliveryFailed": "Failed to retry delivery",
        "retryOutboxFailed": "Failed to retry outbox"
      }
    },
    "workflows": {
      "title": "Workflows",
      "description": "Orchestration de workflows DAG"
    },
    "tenancy": {
      "title": "Locataires",
      "description": "Basculer et gérer les locataires et espaces de noms",
      "quotas": {
        "title": "Gestion des quotas",
        "description": "Configurer et surveiller les quotas de ressources des locataires"
      },
      "governanceMoved": "La gouvernance des locataires a été déplacée vers les pages de détail.",
      "selectTenantDetail": "Sélectionnez un locataire et ouvrez la",
      "detailView": "vue détaillée"
    },
    "asyncInvocations": {
      "title": "Invocations asynchrones",
      "description": "Rechercher des tâches async par ID et inspecter l'état d'exécution"
    },
    "history": {
      "title": "Historique",
      "description": "Historique et tendances des invocations"
    },
    "runtimes": {
      "title": "Environnements",
      "description": "Environnements d'exécution disponibles",
      "failedToLoad": "Échec du chargement des environnements",
      "retry": "Réessayer",
      "loading": "Chargement...",
      "availableCount": "{count} environnements disponibles",
      "addRuntime": "Ajouter un environnement",
      "refresh": "Actualiser",
      "addCustomRuntime": "Ajouter un environnement personnalisé",
      "referenceExisting": "Référencer un existant",
      "uploadNewImage": "Téléverser une nouvelle image",
      "rootfsImage": "Image rootfs (.ext4) *",
      "clickToSelectFile": "Cliquez pour sélectionner un fichier .ext4 (max 2 Go)",
      "idLabel": "ID *",
      "idPlaceholder": "ex. bash-custom",
      "nameLabel": "Nom *",
      "namePlaceholder": "ex. Bash",
      "versionRequiredLabel": "Version *",
      "versionOptionalLabel": "Version (optionnel)",
      "versionPlaceholder": "ex. 5.2",
      "versionValue": "v{version}",
      "imageNameLabel": "Nom de l'image *",
      "imageNamePlaceholder": "ex. bash.ext4",
      "entrypointLabel": "Entrypoint * (séparé par des virgules)",
      "entrypointPlaceholder": "ex. /bin/bash",
      "fileExtensionLabel": "Extension de fichier *",
      "fileExtensionPlaceholder": "ex. .sh",
      "creating": "Création...",
      "uploadAndCreate": "Téléverser et créer",
      "createRuntime": "Créer l'environnement",
      "deleteRuntimeConfirm": "Supprimer cet environnement ?",
      "cancel": "Annuler",
      "deleting": "Suppression...",
      "delete": "Supprimer",
      "itemLabel": "environnements",
      "fileExtensionError": "Le fichier doit avoir l'extension .ext4",
      "fileSizeError": "La taille du fichier doit être inférieure à 2 Go",
      "selectFileToUpload": "Veuillez sélectionner un fichier à téléverser",
      "fillRequiredFields": "Veuillez remplir tous les champs requis",
      "uploading": "Téléversement...",
      "failedToCreate": "Échec de la création de l'environnement",
      "failedToDelete": "Échec de la suppression de l'environnement",
      "functionsCount": "{count, plural, one {# fonction} other {# fonctions}}",
      "status": {
        "available": "disponible",
        "deprecated": "obsolète",
        "maintenance": "maintenance"
      }
    },
    "configurations": {
      "title": "Configurations",
      "description": "Paramètres système et état de santé"
    },
    "secrets": {
      "title": "Secrets",
      "description": "Gérer les secrets chiffrés pour les fonctions"
    },
    "snapshots": {
      "title": "Snapshots",
      "description": "Afficher et gérer les snapshots de VM de fonctions"
    },
    "apiKeys": {
      "title": "Clés API",
      "description": "Gérer les clés API pour l'authentification"
    },
    "gateway": {
      "title": "Passerelle",
      "description": "Gérer les routes HTTP mappées aux fonctions Nova"
    },
    "apiDocs": {
      "title": "Documentation API",
      "description": "Générer et partager de la documentation API avec l'IA",
      "generateTitle": "Générer la documentation",
      "generateDescription": "Sélectionnez une fonction pour générer une documentation API complète avec l'IA",
      "selectFunction": "Fonction",
      "selectFunctionPlaceholder": "Sélectionner une fonction...",
      "generate": "Générer",
      "generating": "Génération...",
      "share": "Partager",
      "createShareLink": "Créer un lien de partage",
      "shareTitle": "Titre du lien",
      "shareTitlePlaceholder": "Ex : Documentation API partenaires",
      "expiry": "Expiration",
      "noExpiration": "Sans expiration",
      "creating": "Création...",
      "createLink": "Créer le lien",
      "sharedLinks": "Liens partagés",
      "refresh": "Actualiser",
      "colTitle": "Titre",
      "colFunction": "Fonction",
      "colExpires": "Expiration",
      "colAccess": "Accès",
      "colActions": "Actions",
      "noShares": "Aucun lien partagé. Générez la documentation et partagez-la.",
      "neverExpires": "Jamais",
      "sourceCodeNotAvailable": "Code source non disponible",
      "generateFailed": "Échec de la génération de la documentation",
      "createShareFailed": "Échec de la création du lien de partage",
      "deleteShareFailed": "Échec de la suppression du lien de partage",
      "expiry24Hours": "24 heures",
      "expiry7Days": "7 jours",
      "expiry30Days": "30 jours",
      "protocol": "Protocole",
      "auth": "Auth",
      "rateLimit": "Limite de débit",
      "timeout": "Délai",
      "endpoint": "Point de terminaison",
      "requestFields": "Champs de requête",
      "responseFields": "Champs de réponse",
      "field": "Champ",
      "type": "Type",
      "required": "Obligatoire",
      "optional": "Optionnel",
      "descriptionLabel": "Description",
      "successCodes": "Codes de succès",
      "errorCodes": "Codes d'erreur",
      "errorModel": "Modèle d'erreur",
      "format": "Format",
      "retryable": "Réessayable",
      "authAndAuthorization": "Authentification et autorisation",
      "method": "Méthode",
      "roles": "Rôles",
      "idempotency": "Idempotence",
      "idempotent": "Idempotent",
      "key": "Clé",
      "observabilityAndPerformance": "Observabilité et performance",
      "tracing": "Traçage",
      "pagination": "Pagination",
      "na": "N/A",
      "yes": "Oui",
      "no": "Non",
      "curlExample": "Exemple cURL",
      "requestExample": "Exemple de requête",
      "responseExample": "Exemple de réponse",
      "errorExample": "Exemple d'erreur",
      "notes": "Notes",
      "changelog": "Journal des modifications",
      "copyLink": "Copier le lien",
      "open": "Ouvrir"
    },
    "apiClient": {
      "title": "Client API",
      "description": "Testez et déboguez les API HTTP directement depuis votre navigateur",
      "send": "Envoyer",
      "sending": "Envoi de la requête…",
      "request": "Requête",
      "response": "Réponse",
      "urlPlaceholder": "https://api.example.com/endpoint",
      "queryParams": "Paramètres",
      "headers": "En-têtes",
      "body": "Corps",
      "variables": "Variables",
      "paramKey": "Nom du paramètre",
      "paramValue": "Valeur",
      "headerKey": "Nom de l'en-tête",
      "headerValue": "Valeur",
      "formKey": "Nom du champ",
      "formValue": "Valeur",
      "bodyType": {
        "none": "Aucun",
        "json": "JSON",
        "form": "Formulaire",
        "raw": "Brut"
      },
      "noBody": "Cette requête n'a pas de corps.",
      "rawBodyPlaceholder": "Saisissez le corps brut de la requête…",
      "pretty": "Formaté",
      "raw": "Brut",
      "responseHeaders": "En-têtes",
      "copy": "Copier",
      "emptyResponse": "Saisissez une URL et cliquez sur Envoyer pour effectuer une requête.",
      "emptyBody": "(vide)",
      "error": "Erreur de requête",
      "elapsed": "{ms} ms",
      "envHint": "Utilisez la syntaxe '{{variable_name}}' dans l'URL, les en-têtes ou le corps pour substituer des valeurs.",
      "addVariable": "Ajouter une variable",
      "add": "Ajouter"
    },
    "rbac": {
      "title": "Contrôle d'accès",
      "description": "Gérer les rôles, permissions et attributions"
    },
    "volumes": {
      "title": "Volumes",
      "description": "Gérer les volumes de stockage persistant"
    },
    "layers": {
      "title": "Couches",
      "description": "Gérer les couches de dépendances partagées"
    },
    "notifications": {
      "title": "Notifications",
      "description": "Afficher et gérer les notifications système"
    }
  },
  "common": {
    "search": "Rechercher des fonctions…",
    "loading": "Chargement…",
    "error": "Erreur",
    "noResults": "Aucun résultat trouvé",
    "create": "Créer",
    "delete": "Supprimer",
    "save": "Enregistrer",
    "cancel": "Annuler",
    "confirm": "Confirmer",
    "back": "Retour",
    "next": "Suivant",
    "retry": "Réessayer",
    "refresh": "Actualiser",
    "close": "Fermer",
    "language": "Langue",
    "docs": "Documentation",
    "health": "Santé"
  },
  "header": {
    "searchPlaceholder": "Rechercher des fonctions…",
    "searching": "Recherche en cours…",
    "noMatchingFunctions": "Aucune fonction correspondante",
    "systemHealth": "Santé du système",
    "overall": "Global",
    "noComponentDetails": "Aucun détail de composant pour le moment.",
    "updated": "Mis à jour",
    "openDocs": "Ouvrir la documentation",
    "notifications": "Notifications",
    "markAllRead": "Tout marquer comme lu",
    "loadingNotifications": "Chargement des notifications…",
    "noNotifications": "Aucune notification",
    "notificationUnreadCount": "non lues",
    "refreshNotifications": "Actualiser les notifications",
    "notificationFilterAll": "Toutes",
    "notificationFilterUnread": "Non lues",
    "notificationMarkRead": "Marquer comme lue",
    "notificationOpenFunction": "Ouvrir la fonction"
  },
  "scopeSwitcher": {
    "failedToLoad": "Échec du chargement des options de locataire.",
    "currentScope": "Portée actuelle : {scope}",
    "switchScope": "Changer la portée du locataire",
    "title": "Portée globale du locataire",
    "description": "Basculer rapidement le locataire et l'espace de noms pour toutes les pages.",
    "tenant": "Locataire",
    "refreshTenantList": "Actualiser la liste des locataires",
    "selectTenant": "Sélectionner un locataire",
    "namespace": "Espace de noms",
    "selectNamespace": "Sélectionner un espace de noms",
    "manage": "Gérer",
    "apply": "Appliquer"
  },
  "commandPalette": {
    "placeholder": "Saisissez une commande ou un nom de fonction…",
    "noResults": "Aucune commande correspondante",
    "openDashboard": "Ouvrir le tableau de bord",
    "viewGlobalMetrics": "Voir les métriques globales",
    "openFunctions": "Ouvrir les fonctions",
    "manageFunctions": "Gérer les fonctions",
    "createFunction": "Créer une fonction",
    "openCreateDialog": "Ouvrir la page des fonctions et la boîte de dialogue de création",
    "openGateway": "Ouvrir la passerelle",
    "manageRoutes": "Gérer les routes",
    "createGatewayRoute": "Créer une route de passerelle",
    "openGatewayCreateDialog": "Ouvrir la page de la passerelle et la boîte de dialogue de création",
    "openEvents": "Ouvrir les événements",
    "eventBus": "Bus d'événements",
    "openHistory": "Ouvrir l'historique",
    "invocationHistory": "Historique des invocations",
    "openTenancy": "Ouvrir les locataires",
    "tenantsAndNamespaces": "Locataires et espaces de noms",
    "openDocs": "Ouvrir la documentation",
    "viewDocs": "Voir la documentation d'installation et de l'API",
    "openFunction": "Ouvrir la fonction : {name}"
  },
  "createFunction": {
    "title": "Créer une nouvelle fonction",
    "functionCreated": "Fonction créée",
    "functionName": "Nom de la fonction",
    "functionNamePlaceholder": "my-function",
    "functionNameHelp": "Format AWS : 1-64 caractères, lettres/chiffres/tiret bas/tiret.",
    "runtime": "Environnement",
    "compiled": "(compilé)",
    "code": "Code",
    "templateLoaded": "Modèle chargé pour {runtime}.",
    "requiresCompilation": " Cet environnement nécessite une compilation.",
    "memoryMb": "Mémoire (Mo)",
    "timeoutS": "Délai d'expiration (s)",
    "handler": "Handler",
    "handlerHelp": "Utilisez le format de handler AWS pour l'environnement actuel.",
    "maxVMs": "VMs max",
    "maxVMsHelp": "Nombre maximum de VMs simultanées pour cette fonction (0 = illimité)",
    "resourceLimits": "Limites de ressources",
    "resourceLimitsHelp": "Configurer CPU, E/S disque et bande passante réseau. Mettre à 0 pour illimité.",
    "vcpus": "vCPUs",
    "vcpu": "vCPU",
    "diskIops": "IOPS disque",
    "diskBw": "Débit disque (o/s)",
    "netRx": "Réception réseau (o/s)",
    "netTx": "Envoi réseau (o/s)",
    "networkPolicy": "Politique réseau",
    "networkPolicyHelp": "Configurer la politique d'entrée/sortie à la création.",
    "isolationMode": "Mode d'isolation",
    "denyExternalAccess": "Refuser l'accès externe",
    "ingressRules": "Règles d'entrée",
    "egressRules": "Règles de sortie",
    "addRule": "Ajouter une règle",
    "noIngressRules": "Aucune règle d'entrée configurée.",
    "noEgressRules": "Aucune règle de sortie configurée.",
    "codeRequired": "Le code est requis",
    "compiling": "Compilation",
    "compiledStatus": "Compilé",
    "failed": "Échec",
    "compilingMessage": "Votre fonction est en cours de compilation. Veuillez patienter…",
    "compiledMessage": "Compilation réussie ! Votre fonction est prête.",
    "compilationFailed": "Échec de la compilation",
    "closeCompiling": "Fermer (compilation en arrière-plan)",
    "done": "Terminé",
    "validationNameFormat": "Le nom de la fonction doit correspondre au format AWS : 1-64 caractères, lettres/chiffres/tiret bas/tiret uniquement.",
    "validationMemoryRange": "La mémoire doit être comprise entre 128 et 10240 Mo (plage AWS Lambda).",
    "validationTimeoutRange": "Le délai d'expiration doit être compris entre 1 et 900 secondes (plage AWS Lambda).",
    "validationJavaHandler": "Le format du handler Java/Kotlin/Scala doit être '<package>.<Class>::<method>'.",
    "validationCompiledHandler": "Le format du handler pour les environnements compilés doit être un nom d'entrée exécutable (lettres/chiffres/_-/).",
    "validationDefaultHandler": "Le format du handler doit être au style AWS '<module>.<function>' (exemple : 'main.handler').",
    "optional": "optionnel",
    "addDeps": "Ajouter des dépendances",
    "removeDeps": "Supprimer",
    "depsHelp": "Ajoutez des dépendances externes via {file}. Elles seront installées lors du déploiement."
  },
  "functionsTable": {
    "unlimited": "Illimité",
    "loadingFunctions": "Chargement des fonctions…",
    "noFunctions": "Aucune fonction trouvée. Créez votre première fonction pour commencer.",
    "function": "Fonction",
    "runtime": "Environnement",
    "status": "Statut",
    "vcpu": "vCPU",
    "memory": "Mémoire",
    "io": "E/S",
    "invocations": "Invocations",
    "errors": "Erreurs",
    "lastModified": "Dernière modification",
    "actions": "Actions",
    "view": "Voir",
    "edit": "Modifier"
  },
  "functionsPage": {
    "dismiss": "Ignorer",
    "searchPlaceholder": "Rechercher des fonctions…",
    "statusPlaceholder": "Statut",
    "runtimePlaceholder": "Environnement",
    "allStatus": "Tous les statuts",
    "active": "Actif",
    "inactive": "Inactif",
    "error": "Erreur",
    "allRuntimes": "Tous les environnements",
    "createFunction": "Créer une fonction",
    "exportSelected": "Exporter la sélection ({count})",
    "exportFiltered": "Exporter les résultats filtrés",
    "importJson": "Importer JSON",
    "selectedCount": "{count} fonction(s) sélectionnée(s)",
    "confirmBulkDelete": "Confirmer la suppression en lot",
    "deleting": "Suppression…",
    "bulkDelete": "Suppression en lot",
    "clearSelection": "Effacer la sélection",
    "noFunctionsYet": "Aucune fonction",
    "noFunctionsDescription": "Créez votre première fonction, puis invoquez-la ou liez-la à la passerelle.",
    "viewDocs": "Voir la documentation",
    "noMatchingFunctions": "Aucune fonction correspondante",
    "noMatchingDescription": "Aucun résultat ne correspond aux filtres actuels. Essayez de les effacer.",
    "clearFilters": "Effacer les filtres",
    "operationResult": "Résultat de l'opération",
    "bulkDeleteFailures": "Suppression en lot terminée avec {count} échec(s). Veuillez vérifier et réessayer.",
    "noFunctionsExport": "Aucune fonction disponible pour l'exportation.",
    "failedReadSource": "Échec de la lecture du code source pour : {names}",
    "noSourceCode": "La fonction {name} n'a pas de code source et ne peut pas être exportée",
    "exportedCount": "{count} fonction(s) exportée(s).",
    "importInvalidFormat": "Aucune définition de fonction valide n'a été trouvée dans le fichier d'importation.",
    "importInvalidFields": "Échec de l'importation : format de fichier invalide ou champs requis manquants.",
    "importInvalidSuffix": ", {count} enregistrement(s) invalide(s) ignoré(s)",
    "importResult": "Importation terminée : {succeeded} réussie(s), {failed} échouée(s){suffix}.",
    "importSuccess": "Importation réussie : {count} fonction(s){suffix}.",
    "importFailed": "Échec de l'importation : {message}",
    "itemLabel": "fonctions"
  },
  "dashboard": {
    "failedToLoad": "Échec du chargement du tableau de bord",
    "auto": "Auto",
    "totalInvocations": "Invocations totales",
    "successful": "{count} réussie(s)",
    "activeFunctions": "Fonctions actives",
    "totalCount": "{count} au total",
    "errorRate": "Taux d'erreur",
    "errorsCount": "{count} erreur(s)",
    "avgDuration": "Durée moyenne",
    "perInvocation": "par invocation",
    "systemIndicators": "Indicateurs système",
    "uptime": "Disponibilité",
    "days": "{count}j",
    "hours": "{count}h",
    "minutes": "{count}min",
    "coldStartRate": "Taux de démarrage à froid",
    "coldWarmRatio": "{cold} à froid / {warm} à chaud",
    "vmPool": "Pool de VM",
    "activeVms": "{count} VM actives",
    "vmLifecycle": "Cycle de vie VM",
    "vmsCreated": "{count} créées",
    "vmsStopped": "{count} arrêtées",
    "vmsCrashed": "{count} crashées",
    "snapshotsHit": "{count} hits snapshot",
    "latencyRange": "Plage de latence",
    "latencyMinMax": "{min}ms – {max}ms",
    "systemStatus": "État du système",
    "statusOk": "Sain",
    "statusDegraded": "Dégradé"
  },
  "activeFunctionsTable": {
    "title": "Fonctions actives",
    "description": "Fonctions les plus populaires par invocations",
    "viewAll": "Voir tout",
    "noFunctions": "Aucune fonction trouvée",
    "name": "Nom",
    "runtime": "Environnement",
    "status": "Statut",
    "invocations": "Invocations"
  },
  "recentLogs": {
    "title": "Journaux récents",
    "description": "Dernières exécutions de fonctions",
    "viewAll": "Voir tout",
    "noLogs": "Aucun journal disponible",
    "durationMs": "{duration}ms"
  },
  "onboarding": {
    "gettingStarted": "Pour commencer",
    "completedCount": "Terminé {count}/3",
    "dismiss": "Ignorer",
    "createFirstFunction": "Créer votre première fonction",
    "createFirstFunctionDesc": "Ajoutez votre logique métier en tant que fonction.",
    "runFunctionOnce": "Exécuter une fonction",
    "runFunctionOnceDesc": "Vérifiez qu'elle s'exécute et produit un enregistrement d'invocation.",
    "createGatewayRoute": "Créer une route de passerelle",
    "createGatewayRouteDesc": "Liez une route HTTP à votre fonction.",
    "invokeFunction": "Invoquer une fonction",
    "createRoute": "Créer une route",
    "openGateway": "Ouvrir la passerelle"
  },
  "charts": {
    "functionInvocations": "Invocations de fonctions",
    "invocations": "Invocations",
    "errorsLabel": "Erreurs",
    "avgExecutionTime": "Temps d'exécution moyen (ms)",
    "avgDuration": "Durée moyenne"
  },
  "pagination": {
    "zeroResults": "0 résultat",
    "showing": "Affichage de {start}–{end} sur {total} {label}",
    "rows": "Lignes",
    "size": "Taille",
    "firstPage": "Première page",
    "previousPage": "Page précédente",
    "page": "Page {number}",
    "nextPage": "Page suivante",
    "lastPage": "Dernière page"
  },
  "quotaManagement": {
    "backToTenancy": "Retour aux locataires",
    "selectTenant": "Locataire",
    "selectTenantPlaceholder": "Sélectionner un locataire",
    "refreshQuotas": "Actualiser les quotas et l'utilisation",
    "configuredCount": "{count} sur {total} quotas configurés",
    "overLimit": "{count} en dépassement",
    "noTenants": "Aucun locataire trouvé. Créez d'abord un locataire.",
    "quotaRules": "Règles de quota",
    "limit": "Limite",
    "unlimited": "Illimité",
    "ofLimit": "de la limite",
    "saveQuota": "Enregistrer le quota",
    "deleteQuota": "Supprimer la règle de quota",
    "loadError": "Échec du chargement des données de quota.",
    "saveError": "Échec de l'enregistrement du quota.",
    "deleteError": "Échec de la suppression du quota.",
    "columnDimension": "Dimension",
    "columnUsage": "Utilisation actuelle",
    "columnHardLimit": "Limite stricte",
    "columnSoftLimit": "Limite souple",
    "columnBurst": "Rafale",
    "columnWindow": "Fenêtre(s)",
    "columnActions": "Actions",
    "dimensions": {
      "invocations": "Invocations",
      "eventPublishes": "Publications d'événements",
      "asyncQueueDepth": "Profondeur de file async",
      "functionsCount": "Nombre de fonctions",
      "memoryMb": "Mémoire",
      "vcpuMilli": "vCPU",
      "diskIops": "IO disque"
    }
  },
  "errorBanner": {
    "defaultTitle": "Échec de la requête",
    "hint": "Indice :",
    "retry": "Réessayer"
  },
  "history": {
    "searchPlaceholder": "Rechercher des invocations…",
    "statusPlaceholder": "Statut",
    "functionPlaceholder": "Fonction",
    "allStatus": "Tous les statuts",
    "success": "Succès",
    "failed": "Échoué",
    "allFunctions": "Toutes les fonctions",
    "totalInvocations": "Total des invocations",
    "successful": "Réussies",
    "coldStarts": "Démarrages à froid",
    "avgDuration": "Durée moyenne",
    "noRecords": "Aucun enregistrement d'invocation",
    "noRecordsDesc": "Invoquez une fonction une fois pour voir l'historique complet des invocations ici.",
    "goToFunctions": "Aller aux fonctions",
    "colStatus": "Statut",
    "colTimestamp": "Horodatage",
    "colFunction": "Fonction",
    "colRequestId": "ID de requête",
    "colDuration": "Durée",
    "colColdStart": "Démarrage à froid",
    "colInput": "Entrée",
    "colOutput": "Sortie",
    "colActions": "Actions",
    "noInvocations": "Aucune invocation trouvée",
    "cold": "Froid",
    "warm": "Chaud",
    "failedToLoad": "Échec du chargement de l'historique des invocations",
    "noInputCaptured": "Aucune entrée capturée",
    "noOutputCaptured": "Aucune sortie capturée",
    "durationMs": "{duration}ms",
    "replayInvocation": "Relancer l'invocation",
    "replayOk": "OK {duration}ms",
    "replayFailed": "Échec",
    "invocationsLabel": "invocations"
  },
  "configurations": {
    "failedToLoad": "Échec du chargement de la configuration",
    "failedToLoadPromptTemplate": "Échec du chargement du modèle de prompt",
    "failedToSaveConfiguration": "Échec de l'enregistrement de la configuration",
    "failedToSaveAiConfiguration": "Échec de l'enregistrement de la configuration IA",
    "failedToSavePromptTemplate": "Échec de l'enregistrement du modèle de prompt",
    "retry": "Réessayer",
    "auto": "Auto",
    "refresh": "Actualiser",
    "systemHealth": "Santé du système",
    "status": "Statut",
    "ok": "ok",
    "healthy": "sain",
    "unhealthy": "malsain",
    "unknown": "inconnu",
    "connected": "Connecté",
    "disconnected": "Déconnecté",
    "activeVMs": "VM actives",
    "poolCount": "Nombre de pools",
    "poolSettings": "Paramètres du pool",
    "idleVmTTL": "TTL des VM inactives (secondes)",
    "idleVmTTLHelp": "Temps avant la terminaison des VM inactives",
    "logLevel": "Niveau de log",
    "logLevelDebug": "Débogage",
    "logLevelInfo": "Info",
    "logLevelWarn": "Avertissement",
    "logLevelError": "Erreur",
    "logLevelHelp": "Niveau de log minimum à capturer",
    "maxGlobalVMs": "VMs globales max",
    "maxGlobalVMsHelp": "Nombre maximum de VMs au niveau du système (0 = illimité)",
    "saving": "Enregistrement…",
    "saveSettings": "Enregistrer les paramètres",
    "saved": "Enregistré",
    "aiSettings": "Paramètres IA",
    "enabled": "Activé",
    "disabled": "Désactivé",
    "aiDescription": "Configurez l'API compatible OpenAI pour la génération, la révision et la réécriture de code par IA.",
    "apiBaseUrl": "URL de base de l'API",
    "apiBaseUrlPlaceholder": "https://api.openai.com/v1",
    "apiBaseUrlHelp": "Point d'accès API OpenAI. Modifiez ceci pour utiliser un fournisseur compatible (ex. Azure OpenAI, LLM local).",
    "promptDirectory": "Répertoire des prompts",
    "promptDirectoryPlaceholder": "configs/prompts/ai",
    "promptDirectoryHelp": "Répertoire utilisé pour les modèles de prompts IA modifiables.",
    "apiKey": "Clé API",
    "apiKeyPlaceholder": "sk-...",
    "showApiKey": "Afficher la clé API",
    "hideApiKey": "Masquer la clé API",
    "apiKeyHelp": "Votre clé API OpenAI. La clé est stockée de manière chiffrée et affichée masquée après l'enregistrement.",
    "model": "Modèle",
    "refreshModels": "Actualiser les modèles",
    "modelHelp": "Modèle IA pour la génération de code. Cliquez sur actualiser pour charger les modèles disponibles depuis l'API.",
    "loadingModels": "Chargement des modèles…",
    "selectModel": "Sélectionner un modèle",
    "enableAiFeatures": "Activer les fonctionnalités IA",
    "toggleAiHelp": "Basculer les fonctionnalités alimentées par l'IA (générer, réviser, réécrire)",
    "saveAiSettings": "Enregistrer les paramètres IA",
    "promptTemplates": "Modèles de prompts",
    "refreshTemplates": "Actualiser les modèles",
    "promptTemplatesDesc": "Gérez les prompts IA centralisés. Les modifications s'appliquent immédiatement aux requêtes IA suivantes.",
    "template": "Modèle",
    "selectPromptTemplate": "Sélectionner un modèle de prompt",
    "templateStatus": "Statut du modèle",
    "customized": "Personnalisé",
    "default": "Par défaut",
    "templateContent": "Contenu du modèle",
    "promptPlaceholder": "Contenu du modèle de prompt…",
    "selectFirst": "Sélectionnez d'abord un modèle",
    "unknownComponent": "Inconnu",
    "savePromptTemplate": "Enregistrer le modèle de prompt",
    "vmSnapshots": "Instantanés VM",
    "noSnapshots": "Aucun instantané créé. Créez des instantanés depuis la page de détails de la fonction.",
    "snapshotsLabel": "instantanés"
  },
  "apiKeysPage": {
    "createApiKey": "Créer une clé API",
    "failedToLoad": "Échec du chargement des clés API",
    "failedToCreate": "Échec de la création de la clé API",
    "failedToDelete": "Échec de la suppression de la clé API",
    "failedToToggle": "Échec de l'activation/désactivation de la clé API",
    "copyKeyNow": "Copiez votre clé API maintenant. Elle ne sera plus affichée.",
    "done": "Terminé",
    "name": "Nom",
    "namePlaceholder": "ma-cle-api",
    "tier": "Niveau",
    "tierDefault": "Par défaut",
    "tierPremium": "Premium",
    "creating": "Création…",
    "colName": "Nom",
    "colTier": "Niveau",
    "colStatus": "Statut",
    "colCreated": "Créé le",
    "colActions": "Actions",
    "noKeys": "Aucune clé API",
    "active": "Actif",
    "disabled": "Désactivé",
    "enableAction": "Activer",
    "disableAction": "Désactiver"
  },
  "workflowsPage": {
    "dismiss": "Ignorer",
    "createWorkflow": "Créer un workflow",
    "totalWorkflows": "Total des workflows",
    "active": "Actif",
    "withVersions": "Avec versions",
    "noWorkflows": "Aucun workflow",
    "noWorkflowsDesc": "Créez un workflow pour orchestrer plusieurs fonctions en tant que DAG.",
    "colName": "Nom",
    "colDescription": "Description",
    "colStatus": "Statut",
    "colVersion": "Version",
    "colUpdated": "Mis à jour",
    "colActions": "Actions",
    "name": "Nom",
    "namePlaceholder": "mon-workflow",
    "description": "Description",
    "descPlaceholder": "Que fait ce workflow ?",
    "creating": "Création…",
    "versionValue": "v{version}",
    "failedToLoad": "Échec du chargement des workflows",
    "workflowCreated": "Workflow « {name} » créé",
    "confirmDeleteNotice": "Cliquez à nouveau sur supprimer pour confirmer la suppression du workflow « {name} »",
    "workflowDeleted": "Workflow « {name} » supprimé"
  },
  "secretsPage": {
    "createSecret": "Créer un secret",
    "failedToLoad": "Échec du chargement des secrets",
    "failedToCreate": "Échec de la création du secret",
    "failedToDelete": "Échec de la suppression du secret",
    "name": "Nom",
    "namePlaceholder": "DATABASE_URL",
    "value": "Valeur",
    "valuePlaceholder": "Entrez la valeur du secret…",
    "encryptionNote": "Les valeurs sont chiffrées au repos. Référencez dans les variables d'environnement avec",
    "referenceFormat": "$SECRET:name",
    "creating": "Création…",
    "colName": "Nom",
    "colCreated": "Créé le",
    "colActions": "Actions",
    "noSecrets": "Aucun secret"
  },
  "snapshotsPage": {
    "failedToLoad": "Échec du chargement des snapshots",
    "failedToDelete": "Échec de la suppression du snapshot",
    "colFunctionName": "Nom de la fonction",
    "colSnapSize": "Taille du snapshot",
    "colMemSize": "Taille mémoire",
    "colTotalSize": "Taille totale",
    "colCreated": "Créé le",
    "colActions": "Actions",
    "noSnapshots": "Aucun snapshot"
  },
  "asyncInvocationsPage": {
    "enterJobId": "Veuillez entrer un ID de tâche.",
    "pasteJobId": "Collez l'ID de tâche asynchrone…",
    "query": "Rechercher",
    "allStatuses": "Tous les statuts",
    "refreshList": "Actualiser la liste",
    "scopeNote": "La requête est limitée au tenant/namespace actuel. Si l'ID de tâche existe dans un autre scope, cette page retourne introuvable.",
    "jobDetail": "Détail de la tâche",
    "openFunction": "Ouvrir la fonction",
    "jobId": "ID de tâche",
    "function": "Fonction",
    "attempts": "Tentatives",
    "nextRun": "Prochaine exécution",
    "requestId": "ID de requête",
    "updated": "Mis à jour",
    "payload": "Charge utile",
    "output": "Sortie",
    "colJobId": "ID de tâche",
    "colFunction": "Fonction",
    "colStatus": "Statut",
    "colAttempts": "Tentatives",
    "colCreated": "Créé le",
    "colUpdated": "Mis à jour",
    "colActions": "Actions",
    "noJobs": "Aucune tâche asynchrone trouvée.",
    "view": "Voir",
    "pause": "Pause",
    "resume": "Reprendre",
    "delete": "Supprimer",
    "retry": "Réessayer",
    "unexpectedError": "Unexpected error.",
    "summaryBacklog": "File d'attente",
    "summaryRunning": "En cours",
    "summarySucceeded": "Réussies",
    "summaryDlq": "File d'attente morte",
    "summaryPaused": "En pause",
    "summaryConsumeSpeed": "Vitesse de consommation",
    "summaryConsumedLast1m": "{count} en 1 min",
    "summaryConsumedLast5m": "{count} en 5 min",
    "summaryPerSec": "{rate}/s",
    "summaryPerMin": "{rate}/min",
    "status": {
      "queued": "queued",
      "running": "running",
      "succeeded": "succeeded",
      "paused": "paused",
      "dlq": "dlq"
    }
  },
  "loginPage": {
    "brand": "Console Nova",
    "title": "User Login",
    "description": "One user can join multiple tenants. Super admin can access all tenants.",
    "username": "Username",
    "password": "Password",
    "signIn": "Sign in",
    "signingIn": "Signing in...",
    "loginFailed": "Login failed.",
    "testUsersTitle": "Built-in test users",
    "testUsersDescription": "Use these accounts to test tenant visibility and switching."
  },
  "tenantDetailPage": {
    "title": "Tenant Detail",
    "titleWithTenant": "Tenant: {tenantId}",
    "description": "Tenant metadata, namespaces, and governance",
    "tenantIdRequired": "Tenant ID is required.",
    "loadFailed": "Failed to load tenant details.",
    "loading": "Loading tenant detail...",
    "notFound": "Tenant '{tenantId}' not found.",
    "backToTenancy": "Back to Tenancy",
    "useThisTenant": "Use This Tenant",
    "detailCardTitle": "Tenant Detail",
    "noNamespaces": "No namespaces",
    "labels": {
      "id": "ID",
      "name": "Name",
      "status": "Status",
      "tier": "Tier",
      "created": "Created",
      "updated": "Updated",
      "namespaces": "Namespaces"
    }
  },
  "workflowDetailPage": {
    "headerTitle": "Workflow: {name}",
    "loadFailed": "Failed to load workflow",
    "dismiss": "Dismiss",
    "backToWorkflows": "Back to Workflows",
    "refresh": "Refresh",
    "triggerRun": "Trigger Run",
    "edit": "Edit",
    "newVersion": "New Version",
    "noPublishedVersion": "No published version yet.",
    "createFirstVersion": "Create First Version",
    "loadingSourceCode": "Loading source code...",
    "noSourceCode": "// No source code available",
    "sourceLoadFailed": "Failed to load source code",
    "cancel": "Cancel",
    "summary": {
      "status": "Status",
      "currentVersion": "Current Version",
      "totalVersions": "Total Versions",
      "totalRuns": "Total Runs"
    },
    "tabs": {
      "graph": "Graph",
      "runs": "Runs",
      "versions": "Versions",
      "docs": "Docs",
      "tests": "Tests"
    },
    "runs": {
      "colRunId": "Run ID",
      "colVersion": "Version",
      "colStatus": "Status",
      "colTrigger": "Trigger",
      "colStarted": "Started",
      "colFinished": "Finished",
      "empty": "No runs yet. Trigger a run to get started."
    },
    "versions": {
      "colVersion": "Version",
      "colCreated": "Created",
      "empty": "No versions published yet."
    },
    "triggerDialog": {
      "title": "Trigger Run",
      "inputHint": "Input JSON to pass to root nodes:",
      "trigger": "Trigger",
      "triggering": "Triggering..."
    },
    "notice": {
      "versionPublished": "Workflow version published",
      "publishFailed": "Failed to publish",
      "runTriggered": "Workflow run triggered",
      "triggerFailed": "Failed to trigger",
      "aiCurlFailed": "Échec de la génération cURL"
    },
    "aiCurl": "AI Curl",
    "aiCurlTitle": "cURL généré par IA",
    "copy": "Copier",
    "copied": "Copié"
  },
  "workflowRunPage": {
    "headerTitle": "Run: {runId}...",
    "headerDescription": "Workflow: {name} | Version: v{version}",
    "loadFailed": "Failed to load run",
    "refresh": "Refresh",
    "backToWorkflow": "Back to {name}",
    "errorTitle": "Error",
    "autoRefreshing": "Auto-refreshing every 2s",
    "loading": "Loading...",
    "loadingSourceCode": "Loading source code...",
    "noSourceCode": "// No source code available",
    "sourceLoadFailed": "Failed to load source code",
    "summary": {
      "status": "Status",
      "trigger": "Trigger",
      "nodes": "Nodes",
      "started": "Started",
      "finished": "Finished"
    },
    "dag": {
      "title": "DAG Visualization"
    },
    "nodeStatus": {
      "title": "Node Status",
      "colNode": "Node",
      "colFunction": "Function",
      "colStatus": "Status",
      "colAttempt": "Attempt",
      "colDeps": "Deps",
      "colStarted": "Started",
      "colFinished": "Finished",
      "colError": "Error",
      "empty": "No nodes."
    },
    "sections": {
      "runOutput": "Run Output",
      "runInput": "Run Input"
    }
  },
  "apiDocsSharedPage": {
    "documentNotAvailable": "Document Not Available",
    "documentNotFound": "The requested document was not found.",
    "documentNotFoundOrExpired": "Document not found or expired",
    "sharedApiDocumentation": "Shared API Documentation",
    "contentType": "Content-Type",
    "required": "Required",
    "optional": "Optional",
    "yes": "Yes",
    "no": "No",
    "na": "N/A",
    "tracingEnabled": "Yes (X-Request-Id)",
    "generatedBy": "Generated by Nova AI · Shared on {date}",
    "labels": {
      "protocol": "Protocol",
      "auth": "Auth",
      "rateLimit": "Rate Limit",
      "timeout": "Timeout",
      "format": "Format",
      "retryable": "Retryable",
      "description": "Description",
      "method": "Method",
      "roles": "Roles",
      "idempotent": "Idempotent",
      "key": "Key",
      "tracing": "Tracing",
      "pagination": "Pagination"
    },
    "table": {
      "field": "Field",
      "type": "Type",
      "required": "Required",
      "default": "Default",
      "description": "Description"
    },
    "sections": {
      "endpoint": "Endpoint",
      "requestFields": "Request Fields",
      "responseFields": "Response Fields",
      "successCodes": "Success Codes",
      "errorCodes": "Error Codes",
      "errorModel": "Error Model",
      "authentication": "Authentication",
      "idempotency": "Idempotency",
      "observability": "Observability & Performance",
      "curlExample": "cURL Example",
      "requestExample": "Request Example",
      "responseExample": "Response Example",
      "errorResponseExample": "Error Response Example",
      "notes": "Notes",
      "changelog": "Changelog"
    }
  },
  "functionDetailPage": {
    "loadFailed": "Failed to load function",
    "functionNotFound": "Function not found",
    "backToFunctions": "Back to Functions",
    "refresh": "Refresh",
    "invoke": "Invoke",
    "enqueue": "Enqueue",
    "coldStart": "cold start",
    "warmStart": "warm start",
    "invalidJsonPayload": "Invalid JSON payload",
    "invocationFailed": "Invocation failed",
    "retryFailed": "Retry failed",
    "invokeMetaAsync": "job_id: {jobId} · status: {status} · attempts: {attempt}/{maxAttempts}",
    "invokeMetaSync": "request_id: {requestId} · duration: {duration} ms · {startState}",
    "retryMeta": "job_id: {jobId} requeued · attempts reset to {attempt}/{maxAttempts}",
    "modeProcess": "process",
    "tabs": {
      "overview": "Overview",
      "code": "Code",
      "logs": "Logs",
      "diagnostics": "Diagnostics",
      "configuration": "Configuration",
      "versions": "Versions",
      "schedules": "Schedules",
      "docs": "Docs",
      "tests": "Tests"
    },
    "versions": {
      "colVersion": "Version",
      "colCodeHash": "Code Hash",
      "colHandler": "Handler",
      "colMemory": "Memory",
      "colTimeout": "Timeout",
      "colMode": "Mode",
      "colCreated": "Created",
      "empty": "No versions published yet"
    },
    "schedules": {
      "createSchedule": "Create Schedule",
      "createTitle": "Create Schedule",
      "editTitle": "Edit Schedule",
      "cronExpression": "Cron Expression",
      "cronPlaceholder": "@every 5m",
      "inputOptionalJson": "Input (optional JSON)",
      "inputPlaceholder": "key: value",
      "create": "Create",
      "creating": "Creating...",
      "save": "Save",
      "never": "Never",
      "statusActive": "Active",
      "statusDisabled": "Disabled",
      "presets": {
        "every1m": "Every 1m",
        "every5m": "Every 5m",
        "every15m": "Every 15m",
        "every30m": "Every 30m",
        "hourly": "Hourly",
        "daily": "Daily",
        "weekly": "Weekly"
      },
      "table": {
        "colCron": "Cron",
        "colStatus": "Status",
        "colLastRun": "Last Run",
        "colCreated": "Created",
        "colActions": "Actions",
        "empty": "No schedules configured"
      }
    },
    "actions": {
      "edit": "Edit",
      "disable": "Disable",
      "enable": "Enable"
    }
  },
  "landingPage": {
    "startCard": {
      "name": "start",
      "codeComment": "// Click to enter"
    }
  },
  "docsShell": {
    "title": "Nova Docs",
    "documentation": "Documentation",
    "onThisPage": "On This Page",
    "search": {
      "placeholder": "Search documentation...",
      "ariaLabel": "Search documentation",
      "noMatches": "No matches for {query}"
    },
    "nav": {
      "guides": "Guides",
      "introduction": "Introduction",
      "architecture": "Architecture",
      "installation": "Installation",
      "reference": "Reference",
      "apiOverview": "API Overview",
      "functionsApi": "Functions API",
      "workflowsApi": "Workflows API",
      "eventsApi": "Events API",
      "operationsApi": "Operations API",
      "orbitCli": "Orbit CLI",
      "atlasMcpServer": "Atlas MCP Server"
    }
  },
  "docsComponents": {
    "schemaTable": {
      "field": "Field",
      "type": "Type",
      "required": "Required",
      "description": "Description",
      "yes": "yes",
      "no": "no"
    },
    "endpointTable": {
      "method": "Method",
      "path": "Path",
      "description": "Description",
      "doc": "Doc",
      "open": "Open"
    },
    "apiSpec": {
      "auth": "Auth",
      "pathParameters": "Path Parameters",
      "queryParameters": "Query Parameters",
      "requestBody": "Request Body",
      "responseBody": "Response Body",
      "successStatus": "Success Status",
      "errorStatus": "Error Status",
      "noEndpointSpecificErrors": "No endpoint-specific errors.",
      "notes": "Notes",
      "requestExample": "Request Example",
      "responseExample": "Response Example",
      "curlExample": "cURL Example",
      "orbitExample": "Orbit Example"
    }
  },
  "docsApiDomainPage": {
    "toc": {
      "coverage": "Coverage",
      "endpointIndex": "Endpoint Index"
    },
    "coverageTitle": "Coverage",
    "endpointIndexTitle": "Endpoint Index",
    "endpointIndexDescription": "Each endpoint has a dedicated contract page with request/response fields, status codes, and examples.",
    "leftSidebarHint": "Endpoint hierarchy is also available in the left sidebar for direct navigation.",
    "nav": {
      "guides": "Guides",
      "introduction": "Introduction",
      "architecture": "Architecture",
      "installation": "Installation",
      "reference": "Reference",
      "apiOverview": "API Overview",
      "orbitCli": "Orbit CLI",
      "atlasMcpServer": "Atlas MCP Server"
    }
  },
  "docsApiEndpointPage": {
    "toc": {
      "contract": "Contract",
      "navigation": "Navigation"
    },
    "navigationTitle": "Navigation",
    "backTo": "Back to {domain}",
    "previous": "Previous: {title}",
    "next": "Next: {title}",
    "nav": {
      "guides": "Guides",
      "introduction": "Introduction",
      "architecture": "Architecture",
      "installation": "Installation",
      "reference": "Reference",
      "apiOverview": "API Overview",
      "orbitCli": "Orbit CLI",
      "atlasMcpServer": "Atlas MCP Server"
    }
  },
  "docsApiOperationsPage": {
    "title": "Operations API",
    "description": "Operational observability and probe endpoints for health, metrics, logs, and recent invocations.",
    "toc": {
      "coverage": "Coverage",
      "health": "Health",
      "healthProbes": "Health Probes",
      "globalTimeseries": "Global Timeseries",
      "functionLogs": "Function Logs",
      "recentInvocations": "Recent Invocations"
    },
    "coverageTitle": "Coverage",
    "coverageDescription": "This section documents runtime health and observability endpoints used by dashboards and SRE workflows."
  },
  "docsApiOverviewPage": {
    "title": "API Overview",
    "description": "Nova API is contract-first and tenant-scoped. Use this page for protocol rules, then open per-endpoint contracts from the left sidebar.",
    "nav": {
      "guides": "Guides",
      "introduction": "Introduction",
      "architecture": "Architecture",
      "installation": "Installation",
      "reference": "Reference",
      "apiOverview": "API Overview",
      "orbitCli": "Orbit CLI",
      "atlasMcpServer": "Atlas MCP Server"
    },
    "toc": {
      "apiBasics": "API Basics",
      "headersAuth": "Headers & Auth",
      "errorFormat": "Error Format",
      "paginationRetries": "Pagination & Retries",
      "referenceSections": "Reference Sections",
      "endpointIndex": "Endpoint Index"
    },
    "sections": {
      "apiBasics": {
        "title": "API Basics",
        "items": {
          "baseUrl": "Base URL:",
          "mediaType": "Default media type:",
          "timeFormat": "Time format: RFC3339 timestamps",
          "tenantAware": "Tenant-aware routing and persistence on every request"
        }
      },
      "headersAuth": {
        "title": "Headers & Auth",
        "description": "Explicit tenant headers are recommended for every write and operator workflow."
      },
      "errorFormat": {
        "title": "Error Format",
        "description": "Most handlers return plain-text errors; some middleware returns structured JSON errors."
      },
      "paginationRetries": {
        "title": "Pagination & Retries",
        "items": {
          "limitAndFilters": "List endpoints generally accept",
          "limitAndFiltersSuffix": "and optional status filters.",
          "asyncIdempotencyPrefix": "Async invocation supports idempotency with",
          "asyncIdempotencySuffix": "and TTL.",
          "subscriptionReplay": "Event subscriptions support replay and seek from sequence/time anchors.",
          "deliveryRetry": "Delivery pipelines use bounded retry with backoff and DLQ transitions."
        }
      },
      "referenceSections": {
        "title": "Reference Sections",
        "description": "Detailed endpoint contracts are split by domain for easier maintenance and faster lookup."
      },
      "endpointIndex": {
        "title": "Endpoint Index",
        "description": "Frequently used endpoints across all API domains."
      }
    }
  },
  "docsArchitecturePage": {
    "title": "Architecture",
    "description": "Nova is designed as a backend service with clear control-plane and data-plane boundaries, durable state, and asynchronous workers for reliable delivery.",
    "toc": {
      "principles": "Design Principles",
      "componentMap": "Component Map",
      "syncInvocationFlow": "Sync Invocation Flow",
      "eventWorkflowDelivery": "Event + Workflow Delivery",
      "tenancyIsolation": "Tenancy & Isolation",
      "reliabilityModel": "Reliability Model",
      "observability": "Observability"
    },
    "sections": {
      "principles": {
        "title": "Design Principles",
        "items": {
          "backendFirst": {
            "label": "Backend-first",
            "value": "Nova is the execution and control backend; Orbit and Lumen are clients."
          },
          "oneControlPlane": {
            "label": "One control plane",
            "value": "Functions, workflows, events, and governance share the same API surface."
          },
          "durability": {
            "label": "Durability by default",
            "value": "Metadata and delivery state are persisted in Postgres."
          },
          "transparency": {
            "label": "Operational transparency",
            "value": "Health, metrics, logs, and replay APIs are first-class endpoints."
          }
        }
      },
      "componentMap": {
        "title": "Component Map"
      },
      "syncInvocationFlow": {
        "title": "Sync Invocation Flow",
        "description": "The synchronous path is optimized for predictable latency with pool reuse and clear backpressure behavior."
      },
      "eventWorkflowDelivery": {
        "title": "Event + Workflow Delivery",
        "description": "Event subscriptions can target functions or workflows. For workflow subscriptions, a webhook may optionally push final outputs externally."
      },
      "tenancyIsolation": {
        "title": "Tenancy & Isolation",
        "items": {
          "item1": "Request scope is resolved from",
          "item1Middle": "and",
          "item2": "Auth-bound identities can only access allowed scopes.",
          "item3": "Store queries are tenant/namespace filtered to prevent data bleed.",
          "item4": "Quotas are enforced per tenant for invocations, queue depth, and event publish dimensions."
        }
      },
      "reliabilityModel": {
        "title": "Reliability Model",
        "items": {
          "retries": {
            "label": "Retries with backoff",
            "value": "Async invocations, event deliveries, and outbox jobs all use bounded attempts and exponential-style backoff."
          },
          "dlq": {
            "label": "DLQ semantics",
            "value": "Terminal failures move to DLQ where operators can replay or retry."
          },
          "replay": {
            "label": "Replay & seek",
            "value": "Subscriptions support replay from sequence/time and cursor reset."
          },
          "idempotency": {
            "label": "Idempotency",
            "value": "Async invocation API supports idempotency key + TTL to avoid duplicate work."
          }
        }
      },
      "observability": {
        "title": "Observability",
        "items": {
          "item1": "Health endpoints:",
          "item2": "Operational metrics:",
          "item3": "Function-level diagnostics:",
          "item4": "Pool and system status:",
          "item4Suffix": "invocation history via"
        }
      }
    }
  },
  "docsCliPage": {
    "title": "Orbit CLI",
    "description": "Orbit is the primary CLI for Nova operations. Nova binary now runs backend services only (daemon mode).",
    "toc": {
      "positioning": "Positioning",
      "globalContext": "Global Context",
      "commandGroups": "Command Groups",
      "taskRecipes": "Task Recipes",
      "pullLocalTest": "Pull & Local Test",
      "troubleshooting": "Troubleshooting"
    },
    "sections": {
      "positioning": {
        "title": "Positioning",
        "items": {
          "novaBinary": {
            "label": "Nova binary",
            "value": "Backend service process only, run with"
          },
          "orbitCli": {
            "label": "Orbit CLI",
            "value": "Full operational surface for functions, workflows, events, tenants, secrets, metrics, and gateway."
          }
        }
      },
      "globalContext": {
        "title": "Global Context",
        "description": "Orbit resolves target server and tenant scope from flags, environment variables, or local config."
      },
      "commandGroups": {
        "title": "Command Groups"
      },
      "taskRecipes": {
        "title": "Task Recipes",
        "description": "Use these as copy-paste starters for common operator workflows."
      },
      "pullLocalTest": {
        "title": "Pull & Local Test",
        "description": "Orbit can pull remote function source to local workspace and run a local test with your payload. If runtime toolchain is missing, Orbit prints install instructions directly.",
        "items": {
          "item1": "Auto local runner currently supports Python and Node.js runtimes.",
          "item2": "Go/Rust/Java runtimes still pull source and check toolchain, then show manual test guidance.",
          "item3Prefix": "Pulled files include source code,",
          "item3Middle": ", and"
        }
      },
      "troubleshooting": {
        "title": "Troubleshooting",
        "items": {
          "item1Prefix": "If commands fail with scope errors, set",
          "item1Middle": "and",
          "item1Suffix": "explicitly.",
          "item2Prefix": "If auth is enabled, verify",
          "item2Suffix": "or Authorization header configuration.",
          "item3": "If create/invoke succeeds but metrics look empty, check the selected tenant badge in Lumen.",
          "item4Prefix": "For noisy output in automation, use",
          "item4Suffix": "and parse deterministically."
        }
      }
    }
  },
  "docsInstallationPage": {
    "title": "Installation",
    "description": "Linux x86_64 zero-to-service installation guide based on scripts/setup.sh. Includes full build flow, deployment modes, and component responsibilities.",
    "toc": {
      "beforeYouBegin": "Before You Begin",
      "deploymentModes": "Deployment Modes",
      "devModeDocker": "Mode A: Docker Dev",
      "linuxZeroToService": "Mode B: Linux Zero-to-Service",
      "whatSetupDoes": "What setup.sh Does",
      "componentRoles": "Component Roles",
      "verifyInstallation": "Verify Installation",
      "orbitAndAtlas": "Orbit and Atlas",
      "operationsChecklist": "Operations Checklist"
    },
    "sections": {
      "beforeYouBegin": {
        "title": "Before You Begin",
        "description": "The one-click script targets Linux x86_64 servers and expects prebuilt Nova binaries.",
        "items": {
          "item1": "OS/Arch: Linux + x86_64",
          "item2Prefix": "Privileges: root (run with",
          "item2Suffix": ")",
          "item3Prefix": "Hardware:",
          "item3Suffix": "recommended for Firecracker VM execution",
          "item4Prefix": "Build toolchain: Go",
          "item5Prefix": "Ports:",
          "item5Middle": "(Zenith gateway/API entrypoint),",
          "item5Middle2": "(Lumen UI),",
          "item5Suffix": "(PostgreSQL)"
        },
        "dataSafetyTitle": "Data safety note",
        "dataSafetyBodyPrefix": "performs a fresh deployment and recreates the",
        "dataSafetyBodySuffix": "database. Existing data will be removed."
      },
      "deploymentModes": {
        "title": "Deployment Modes",
        "description": "Nova supports two practical installation modes:",
        "items": {
          "modeA": {
            "label": "Mode A (Docker Dev)",
            "value": "Fastest local development path, containerized stack."
          },
          "modeB": {
            "label": "Mode B (Linux Zero-to-Service)",
            "valuePrefix": "Build binaries + run",
            "valueSuffix": "for host-level deployment with systemd."
          }
        }
      },
      "devModeDocker": {
        "title": "Mode A: Docker Dev",
        "description": "Use this when you need a quick local environment for feature work and docs browsing."
      },
      "linuxZeroToService": {
        "title": "Mode B: Linux Zero-to-Service",
        "descriptionPrefix": "This is the full from-scratch flow on Linux host. It builds binaries and lets",
        "descriptionSuffix": "install PostgreSQL, Firecracker, rootfs images, Nova, and Lumen as systemd services.",
        "remoteVariant": "Remote deployment variant (build locally, run setup remotely):"
      },
      "whatSetupDoes": {
        "title": "What setup.sh Does",
        "descriptionPrefix": "Internally,",
        "descriptionSuffix": "executes these stages in order:",
        "items": {
          "item1": "Checks root permissions, Linux/x86_64, and binary artifacts.",
          "item2": "Installs host dependencies and Node.js 20.",
          "item3Prefix": "Resets previous installation state under",
          "item3Middle": "and",
          "item4Prefix": "Installs and initializes PostgreSQL; recreates",
          "item4Suffix": "role/database.",
          "item5Prefix": "Applies",
          "item5Suffix": "schema and default records.",
          "item6": "Installs Firecracker + Jailer and downloads Firecracker-compatible kernel.",
          "item7Prefix": "Deploys Nova binaries and generates",
          "item8Prefix": "Builds all runtime rootfs images (",
          "item8Middle": "), each embedding",
          "item8Suffix": "as",
          "item9Prefix": "Builds Lumen (Next.js standalone) and deploys to",
          "item10Prefix": "Creates and starts",
          "item10Middle": "and",
          "item11": "Seeds sample functions via Nova API for initial validation."
        }
      },
      "componentRoles": {
        "title": "Component Roles",
        "description": "Components used in the full Linux deployment and what each one does:",
        "table": {
          "component": "Component",
          "type": "Type",
          "role": "Role"
        },
        "rows": {
          "postgresql": {
            "type": "Database",
            "role": "Persists control-plane state, metadata, logs, keys, and configuration."
          },
          "initDb": {
            "type": "Schema bootstrap",
            "role": "Creates tables/indexes and default records required by Nova."
          },
          "novaBinary": {
            "type": "Backend service",
            "role": "Runs Nova API/control plane on port 9000."
          },
          "novaAgent": {
            "type": "Guest runtime agent",
            "role": "Executed inside VM rootfs as /init to run function workloads."
          },
          "firecracker": {
            "type": "VM runtime",
            "role": "Provides lightweight microVM isolation for function execution."
          },
          "kernel": {
            "type": "Kernel artifact",
            "role": "Linux kernel used by Firecracker guest VMs."
          },
          "rootfs": {
            "type": "Runtime images",
            "role": "Language-specific root filesystems (python/node/go/java/...)"
          },
          "lumenService": {
            "type": "UI service",
            "role": "Runs Lumen dashboard (Next.js standalone) on port 3000."
          },
          "novaService": {
            "type": "systemd unit",
            "role": "Supervises Nova daemon process and restart policy."
          },
          "installRoot": {
            "type": "Install root",
            "role": "Holds binaries, configs, kernel, rootfs, snapshots, and UI bundle."
          },
          "runtimeTempDir": {
            "type": "Runtime temp dir",
            "role": "Stores sockets, vsock files, and execution logs during runtime."
          }
        }
      },
      "verifyInstallation": {
        "title": "Verify Installation",
        "items": {
          "item1Prefix": "Check systemd status for",
          "item1Middle": "and",
          "item2": "Check backend health endpoints (Zenith entrypoint).",
          "item3": "Call API once to confirm function lifecycle works."
        }
      },
      "orbitAndAtlas": {
        "title": "Orbit and Atlas",
        "description": "deploys backend and UI. Orbit CLI and Atlas MCP are built separately when needed."
      },
      "operationsChecklist": {
        "title": "Operations Checklist",
        "items": {
          "item1": "Enable auth and tenant governance before exposing APIs outside trusted networks.",
          "item2": "Back up PostgreSQL and verify restore procedures regularly.",
          "item3": "Pin Firecracker/kernel versions in controlled environments instead of floating latest.",
          "item4Prefix": "Monitor",
          "item4Middle": "and",
          "item4Suffix": "for runtime issues.",
          "item5": "Set up metrics/tracing exporters and retention policy for invocation logs.",
          "item6Prefix": "Treat rerunning",
          "item6Suffix": "as a re-provision operation, not an in-place upgrade."
        }
      },
      "dailyCommands": {
        "title": "Daily Commands"
      }
    }
  },
  "docsMcpServerPage": {
    "title": "Atlas MCP Server",
    "description": "Atlas exposes Nova capabilities as MCP tools so AI agents can operate Nova through a typed stdio tool interface.",
    "toc": {
      "overview": "Overview",
      "whenToUse": "When To Use",
      "buildAndRun": "Build & Run",
      "connectionConfig": "Connection Config",
      "toolSurface": "Tool Surface",
      "operationalGuidance": "Operational Guidance"
    },
    "sections": {
      "overview": {
        "title": "Overview",
        "descriptionPrefix": "Atlas is implemented in Go and runs over MCP stdio transport. It maps Nova HTTP APIs to MCP tools with a consistent",
        "descriptionSuffix": "naming convention."
      },
      "whenToUse": {
        "title": "When To Use",
        "items": {
          "item1": "Automate operational runbooks from AI coding/ops assistants.",
          "item2": "Drive function, workflow, and event operations from natural language requests.",
          "item3": "Keep the same tenant/namespace scoping model as Orbit and HTTP clients."
        }
      },
      "buildAndRun": {
        "title": "Build & Run"
      },
      "connectionConfig": {
        "title": "Connection Config",
        "description": "Atlas reads backend context from environment variables and forwards them as Nova request headers."
      },
      "toolSurface": {
        "title": "Tool Surface",
        "description": "Atlas tools are grouped by domain to mirror Nova APIs.",
        "items": {
          "functions": "Functions: lifecycle, code, versions, invocation, async invocation.",
          "workflows": "Workflows: create/update/list, versions, runs.",
          "events": "Events: topics, subscriptions, deliveries, replay, outbox.",
          "governance": "Governance: tenants, API keys, secrets, config.",
          "operations": "Operations: health, stats, metrics, logs, invocations."
        }
      },
      "operationalGuidance": {
        "title": "Operational Guidance",
        "items": {
          "item1": "Always set tenant and namespace explicitly in shared environments.",
          "item2": "Prefer least-privilege API keys per automation/agent workflow.",
          "item3": "Treat MCP tool responses as source-of-truth runtime state, not cached assumptions.",
          "item4": "Use replay/seek/dlq tools for controlled recovery instead of ad-hoc DB changes."
        }
      }
    }
  },
  "docsIntroPage": {
    "title": "Introduction",
    "description": "Nova is a backend-first serverless control plane. It provides function execution, workflow orchestration, event delivery, and tenant-aware operations behind one API.",
    "toc": {
      "whoThisIsFor": "Who This Is For",
      "whatYouGet": "What You Get",
      "controlSurfaceComparison": "Control Surface Comparison",
      "docsMap": "Docs Map",
      "recommendedLearningPath": "Recommended Learning Path",
      "firstSmokeTest": "First Smoke Test",
      "nextSteps": "Next Steps"
    },
    "jumpToComparison": {
      "prefix": "Looking for capability differences? Jump to",
      "suffix": "."
    },
    "comparison": {
      "badges": {
        "full": "Full",
        "partial": "Partial",
        "notPrimary": "Not Primary"
      }
    },
    "sections": {
      "whoThisIsFor": {
        "title": "Who This Is For",
        "description": "This documentation is for platform engineers and backend developers who want to run Nova as a multi-tenant serverless backend and operate it with Orbit CLI.",
        "items": {
          "item1": "You need one backend API for functions, workflows, and event-driven delivery.",
          "item2": "You want tenant and namespace isolation at request level.",
          "item3": "You need local development parity with production-like operational primitives."
        }
      },
      "whatYouGet": {
        "title": "What You Get",
        "items": {
          "functionControl": {
            "label": "Function runtime control",
            "value": "Create/update/invoke functions, observe logs and metrics."
          },
          "workflowOrchestration": {
            "label": "Workflow orchestration",
            "value": "Publish workflow definitions and trigger runs."
          },
          "eventBus": {
            "label": "Event bus",
            "value": "Topics, subscriptions, delivery retries, replay, outbox relay."
          },
          "platformGovernance": {
            "label": "Platform governance",
            "value": "Tenants, namespaces, quotas, API keys, secrets."
          },
          "operationsTooling": {
            "label": "Operations tooling",
            "value": "Orbit CLI for operators and Atlas MCP server for AI tooling."
          }
        }
      },
      "comparison": {
        "title": "Control Surface Comparison",
        "description": "Nova exposes the same backend through three operation surfaces. They overlap heavily but are not identical. Use this matrix to pick the right entry point for each task.",
        "columns": {
          "capability": "Capability",
          "lumenUi": "Lumen UI",
          "orbitCli": "Orbit CLI",
          "atlasMcp": "Atlas MCP",
          "notes": "Notes"
        },
        "choose": {
          "lumenTitle": "Choose Lumen UI when",
          "lumenDescription": "you need visual inspection, quick interactive edits, and dashboard-driven troubleshooting.",
          "orbitTitle": "Choose Orbit CLI when",
          "orbitDescription": "you need full API coverage, repeatable scripts, CI/CD integration, and bulk operations.",
          "atlasTitle": "Choose Atlas MCP when",
          "atlasDescription": "you want AI agents to call typed Nova tools directly with tenant-scoped context."
        },
        "rows": {
          "functionsLifecycle": {
            "capability": "Functions lifecycle + invoke + logs",
            "note": "All three cover daily function development and operations."
          },
          "workflowsLifecycle": {
            "capability": "Workflows (define/version/run)",
            "note": "Complete workflow lifecycle is available across all interfaces."
          },
          "eventsLifecycle": {
            "capability": "Events (topic/subscription/delivery/replay)",
            "note": "End-to-end event delivery controls are available in each surface."
          },
          "tenancyGovernance": {
            "capability": "Tenancy governance (quotas/usage)",
            "note": "Tenant and namespace governance is exposed everywhere."
          },
          "gatewayRoutes": {
            "capability": "Gateway route management",
            "note": "Gateway operations are currently CLI/MCP-first."
          },
          "layerManagement": {
            "capability": "Layer management",
            "note": "Layer operations are currently CLI/MCP-first."
          },
          "batchAutomation": {
            "capability": "Scriptable batch automation",
            "note": "Lumen can operate interactively; automation is stronger with Orbit/MCP."
          },
          "aiToolCalling": {
            "capability": "AI-native tool calling",
            "note": "MCP is designed for agentic and assistant-driven operations."
          }
        }
      },
      "docsMap": {
        "title": "Docs Map",
        "description": "The docs are split into guides and reference pages to match common engineering workflows."
      },
      "learningPath": {
        "title": "Recommended Learning Path",
        "items": {
          "architecture": {
            "prefix": "Read",
            "link": "Architecture",
            "suffix": "to understand control plane vs data plane and delivery pipelines."
          },
          "installation": {
            "prefix": "Follow",
            "link": "Installation",
            "suffix": "to stand up Nova + Lumen + Orbit in your environment."
          },
          "api": {
            "prefix": "Use",
            "link": "API Reference",
            "suffix": "for request and response schemas while integrating clients."
          },
          "cli": {
            "prefix": "Keep",
            "link": "Orbit CLI",
            "suffix": "open for operational tasks and day-2 operations."
          }
        }
      },
      "firstSmokeTest": {
        "title": "First Smoke Test",
        "description": "After deployment, run this minimal end-to-end test to verify API reachability, function lifecycle, and execution path."
      },
      "nextSteps": {
        "title": "Next Steps",
        "actions": {
          "architecture": "Read Architecture",
          "installation": "Run Installation",
          "api": "Open API Reference"
        }
      }
    }
  },
  "testSuite": {
    "testCase": "Cas de test",
    "passed": "réussi(s)",
    "failed": "échoué(s)",
    "executed": "exécuté(s)",
    "addTestCase": "Ajouter un cas de test",
    "addFirstTestCase": "Ajouter le premier cas de test",
    "runAll": "Tout exécuter",
    "save": "Enregistrer",
    "aiGenerate": "Générer par IA",
    "input": "Entrée",
    "expectedOutput": "Sortie attendue",
    "expectedOutputPlaceholder": "Laisser vide pour ignorer la vérification",
    "actualOutput": "Sortie réelle",
    "result": "Résultat",
    "running": "En cours...",
    "emptyDescription": "Aucun cas de test. Ajoutez des cas de test pour valider votre fonction.",
    "workflowEmptyDescription": "Aucun cas de test. Ajoutez des cas de test pour valider votre workflow.",
    "workflowNoVersion": "Ce workflow n'a pas de version publiée. Publiez une version avant d'exécuter les tests.",
    "workflowRunning": "Exécution du workflow...",
    "viewRun": "Voir l'exécution"
  },
  "gatewayPage": {
    "titles": {
      "loadError": "Failed to Load Gateway Configuration",
      "createRoute": "Create Gateway Route",
      "editRoute": "Edit Gateway Route"
    },
    "fields": {
      "defaultRateLimitTemplate": "Default Rate Limit Template",
      "rps": "RPS",
      "burst": "Burst",
      "domain": "Domain",
      "path": "Path",
      "methodsCsv": "Methods (comma-separated)",
      "function": "Function",
      "authStrategy": "Auth Strategy",
      "enabled": "Enabled",
      "rateLimitRpsOptional": "Rate Limit RPS (optional)",
      "rateLimitBurstOptional": "Rate Limit Burst (optional)"
    },
    "placeholders": {
      "rps": "20",
      "burst": "40",
      "filterByDomain": "Filter by domain...",
      "domainOptional": "api.example.com (optional)",
      "path": "/v1/orders",
      "methods": "GET,POST",
      "selectFunction": "Select function",
      "rpsExample": "e.g. 20",
      "burstExample": "e.g. 40"
    },
    "buttons": {
      "dismiss": "Dismiss",
      "saveTemplate": "Save Template",
      "saving": "Saving...",
      "exportSelected": "Export Selected ({count})",
      "exportFiltered": "Export Filtered",
      "importJson": "Import JSON",
      "addRoute": "Add Route",
      "cancel": "Cancel",
      "create": "Create",
      "refresh": "Refresh",
      "bulkEnable": "Bulk Enable",
      "bulkDisable": "Bulk Disable",
      "confirmBulkDelete": "Confirm Bulk Delete",
      "bulkDelete": "Bulk Delete",
      "clearSelection": "Clear Selection",
      "createFunctionFirst": "Create Function First",
      "clearFilter": "Clear Filter",
      "disableRoute": "Disable route",
      "enableRoute": "Enable route",
      "editRoute": "Edit route",
      "confirmDeleteRoute": "Confirm delete route",
      "cancelDeleteRoute": "Cancel delete route",
      "deleteRoute": "Delete route",
      "confirm": "Confirm",
      "save": "Save"
    },
    "labels": {
      "enabled": "enabled",
      "disabled": "disabled",
      "allMethods": "ALL",
      "selectedCount": "Selected {count} route(s)",
      "rateLimitValue": "{rps}/s, burst {burst}",
      "importInvalidSuffix": ", skipped {count} invalid record(s)"
    },
    "authStrategies": {
      "none": "none",
      "inherit": "inherit",
      "apikey": "apikey",
      "jwt": "jwt"
    },
    "hints": {
      "defaultTemplate": "New routes without explicit rate limits will inherit this template.",
      "currentDefault": "Current default: {rps}/s, burst {burst}"
    },
    "empty": {
      "noRoutesTitle": "No Gateway Routes Yet",
      "noRoutesDescription": "Create a route so UI / CLI / MCP can call through Zenith.",
      "noMatchingTitle": "No Matching Routes",
      "noMatchingDescription": "No routes match the current domain filter."
    },
    "table": {
      "id": "ID",
      "domain": "Domain",
      "path": "Path",
      "methods": "Methods",
      "function": "Function",
      "auth": "Auth",
      "rateLimit": "Rate Limit",
      "status": "Status",
      "updated": "Updated",
      "actions": "Actions"
    },
    "notices": {
      "templateSaved": "Gateway default rate-limit template saved",
      "routeCreated": "Gateway route created",
      "routeUpdated": "Gateway route updated",
      "confirmDelete": "Click delete again to confirm route \"{id}\" deletion",
      "routeDeleted": "Route \"{id}\" deleted",
      "routeToggled": "Route \"{id}\" {status}",
      "bulkUpdateFailures": "Bulk update completed with {count} failed route(s).",
      "bulkUpdated": "Bulk {status} {count} route(s).",
      "bulkDeleteFailures": "Bulk delete completed with {count} failed route(s).",
      "bulkDeleted": "Deleted {count} route(s).",
      "exportedCount": "Exported {count} route(s).",
      "importResult": "Import finished: {succeeded} succeeded, {failed} failed{suffix}.",
      "importSuccess": "Import succeeded: {count} route(s){suffix}."
    },
    "errors": {
      "defaultTemplateRps": "Default template RPS must be > 0 when enabled.",
      "defaultTemplateBurst": "Default template burst must be > 0 when enabled.",
      "pathRequired": "Path is required.",
      "functionRequired": "Function is required.",
      "noRoutesExport": "No routes available for export.",
      "importNoValid": "No valid route definitions were found in the import file.",
      "importInvalidFields": "Import failed: invalid file format or missing required fields.",
      "importFailed": "Import failed: {message}"
    }
  },
  "rbacPage": {
    "roles": "Rôles",
    "permissions": "Permissions",
    "assignments": "Attributions",
    "createRole": "Créer un rôle",
    "createPermission": "Créer une permission",
    "createAssignment": "Créer une attribution",
    "noRoles": "Aucun rôle",
    "noPermissions": "Aucune permission",
    "noAssignments": "Aucune attribution",
    "failedToLoad": "Échec du chargement",
    "failedToCreate": "Échec de la création",
    "failedToDelete": "Échec de la suppression",
    "name": "Nom",
    "namePlaceholder": "ex. admin",
    "code": "Code",
    "codePlaceholder": "ex. functions:read",
    "resourceType": "Type de ressource",
    "resourceTypePlaceholder": "ex. functions",
    "action": "Action",
    "actionPlaceholder": "ex. read",
    "description": "Description",
    "descriptionPlaceholder": "Décrivez cette permission...",
    "principalType": "Type de principal",
    "principalTypePlaceholder": "ex. user",
    "principalId": "ID du principal",
    "principalIdPlaceholder": "ex. user-123",
    "roleId": "ID du rôle",
    "roleIdPlaceholder": "Sélectionnez un rôle...",
    "scopeType": "Type de portée",
    "scopeTypePlaceholder": "ex. tenant",
    "scopeId": "ID de portée",
    "scopeIdPlaceholder": "ex. tenant-123",
    "creating": "Création...",
    "colName": "Nom",
    "colSystem": "Système",
    "colCreated": "Créé le",
    "colActions": "Actions",
    "colCode": "Code",
    "colResource": "Ressource",
    "colAction": "Action",
    "colDescription": "Description",
    "colPrincipal": "Principal",
    "colRoleId": "ID du rôle",
    "colScope": "Portée",
    "yes": "Oui",
    "no": "Non"
  },
  "volumesPage": {
    "createVolume": "Créer un volume",
    "failedToLoad": "Échec du chargement des volumes",
    "failedToCreate": "Échec de la création du volume",
    "failedToDelete": "Échec de la suppression du volume",
    "name": "Nom",
    "namePlaceholder": "ex. my-data",
    "sizeMb": "Taille (Mo)",
    "shared": "Partagé",
    "description": "Description",
    "descriptionPlaceholder": "Décrivez ce volume...",
    "creating": "Création...",
    "colName": "Nom",
    "colSize": "Taille",
    "colShared": "Partagé",
    "colDescription": "Description",
    "colCreated": "Créé le",
    "colActions": "Actions",
    "noVolumes": "Aucun volume",
    "yes": "Oui",
    "no": "Non"
  },
  "layersPage": {
    "createLayer": "Créer une couche",
    "failedToLoad": "Échec du chargement des couches",
    "failedToCreate": "Échec de la création de la couche",
    "failedToDelete": "Échec de la suppression de la couche",
    "name": "Nom",
    "namePlaceholder": "ex. numpy-layer",
    "runtime": "Runtime",
    "runtimePlaceholder": "ex. python",
    "version": "Version",
    "versionPlaceholder": "ex. 1.0.0",
    "creating": "Création...",
    "colName": "Nom",
    "colRuntime": "Runtime",
    "colVersion": "Version",
    "colSize": "Taille",
    "colFiles": "Fichiers",
    "colCreated": "Créé le",
    "colActions": "Actions",
    "noLayers": "Aucune couche",
    "filesCount": "{count} fichiers"
  },
  "notificationsPage": {
    "failedToLoad": "Échec du chargement des notifications",
    "all": "Toutes",
    "unread": "Non lues",
    "read": "Lues",
    "markAllRead": "Tout marquer comme lu",
    "markRead": "Marquer comme lu",
    "noNotifications": "Aucune notification",
    "severity": "Sévérité",
    "function": "Fonction",
    "source": "Source"
  }
}
